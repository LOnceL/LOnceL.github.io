<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>弦&amp;棒的振动</title>
      <link href="/posts/42549.html"/>
      <url>/posts/42549.html</url>
      
        <content type="html"><![CDATA[<h3 id="弦振动"><a href="#弦振动" class="headerlink" title="弦振动"></a>弦振动</h3><h4 id="弦的振动方程"><a href="#弦的振动方程" class="headerlink" title="弦的振动方程"></a>弦的振动方程</h4><span id="more"></span><p>对弦上$x\rightarrow x+\mathrm{d}x$元段进行受力分析之后利用牛顿第二定律可以推出：</p><script type="math/tex; mode=display">\dfrac{\partial^2\eta}{\partial x^2} = \dfrac{1}{c^2}\dfrac{\partial^2\eta}{\partial t^2}</script><p>其中：$\eta$是元段的垂直位移，$c^2 = \dfrac{T}{\delta}$, $\delta = \rho S$是线密度.</p><h4 id="通解"><a href="#通解" class="headerlink" title="通解"></a>通解</h4><p>设$\delta$和$T$均为常数，我们用行波法:</p><script type="math/tex; mode=display">\begin{cases}\zeta = ct + x \\\xi = ct - x.\end{cases}</script><p>弦波方程变换为：</p><script type="math/tex; mode=display">\dfrac{\partial^2 \eta}{\partial x^2} - \dfrac{1}{c^2}\dfrac{\partial^2\eta}{\partial t^2} = \bigg( \dfrac{\partial}{\partial x} + \dfrac{1}{c} \dfrac{\partial}{\partial t} \bigg)\bigg( \dfrac{\partial}{\partial x} - \dfrac{1}{c} \dfrac{\partial}{\partial t} \bigg)\eta = 0 \ \ \ \rightarrow \ \ \ \dfrac{\partial^2\eta}{\partial \xi \partial \zeta} = 0</script><p>于是$\eta$是分别为沿$x$正反方向以速度$c$传播的行波：</p><script type="math/tex; mode=display">\eta(x,t) = f(\xi)+g(\zeta)=f(ct-x)+f(ct+x)</script>]]></content>
      
      
      <categories>
          
          <category> Physics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Acoustics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有向图 tarjan 算法</title>
      <link href="/posts/4944.html"/>
      <url>/posts/4944.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>强连通：在一个有向图中，有两节点a，b。如果从a可以走到b，并且从b也有路径走到a，那么我们称节点a，b强连通。</p></li><li><p>强连通图:如果在一个有向图中，任意不同的两点都强连通，那么我们称这个图为强连通图。</p></li><li><p>强连通分量：在有向图G中，有一个子图，这个子图每两个点强连通，那么我们就叫这个子图为强连通分量。</p></li></ul><blockquote><p>分量：把一个向量分解成几个方向的向量的和，这些方向上的向量就叫做该向量的分量。</p></blockquote><p>​       举一个小例子：<span id="more"></span></p><p><img src="https://i.loli.net/2018/11/07/5be23bd0bb890.png" alt="强连通.png"></p><p>​       在本图中，点1可以走到点2，点2也可以走到点1，那么，点1,2是强连通的。</p><p>​       同时，1,2,3所组成的图是互相可以到达的，它们组成一个强连通分量</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>​       tarjan之所以使用DFS(<del>迪法师</del>)就是因为它将每一个强连通分量作为搜索树上的一个子树。这个图，就是一个完整的一个搜索图。</p><p>​       对于每一个节点，都有两个参数 $low$,$dfn$.</p><blockquote><p>$dfn[\ \   ]$是搜索的时间戳，存储该点的访问时间。</p></blockquote><h4 id="回溯值"><a href="#回溯值" class="headerlink" title="回溯值"></a>回溯值</h4><p>​       设subtree($x$)是图的搜索树中以$x$为根的子树。$x$的追溯值$low[\ \ ]$定义为满足以下条件的节点的最小时间戳：</p><ol><li><p>当节点x第一次被访问时，将$x$入栈，初始化$low[x]=dfn[x]$.</p></li><li><p>扫描从$x$出发的每一条边$(x,y)$<br>  (1) 若$y$没有被访问过，则$(x,y)$为树枝边。递归访问$y$，从$y$回溯之后，令$low[x]=\min(low[x],low[y])$.</p><p>  (2) 若$y$已被访问并且$y$还在栈中，那么令$low[x]=\min(low[x],dfn[y])$.</p></li><li>从$x$回溯之前，判断是否有$dfn[x]=low[x]$。如果成立，则不断从栈中弹出节点，直至$x$出栈。</li></ol><h3 id="判定法则"><a href="#判定法则" class="headerlink" title="判定法则"></a>判定法则</h3><p>​       在回溯值计算的过程中，如果从$x$回溯前，有$dfn[x]=low[x]$成立，则栈中从$x$到栈顶的所有节点构成一个强连通分量。</p><p>​       在上面计算回溯值的第三步的时候，若$dfn[x]=low[x]$,那么就说明subtree($x$)中的节点无法与栈中的节点构成环。</p><h3 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出一个有向图中的所有的强联通分量</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> head[maxn],tot,n,m,low[maxn],dfn[maxn],index;</span><br><span class="line"><span class="type">int</span> stack[maxn],vis[maxn];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="type">int</span> v,next;</span><br><span class="line">&#125; e[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addnode</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">e[++tot].next = head[x];</span><br><span class="line">e[tot].v = y;</span><br><span class="line">head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">low[u] = dfn[u] = ++cnt;<span class="comment">//初始化 </span></span><br><span class="line">stack[++index] = u;<span class="comment">//入栈 </span></span><br><span class="line">vis[u] = <span class="number">1</span>;<span class="comment">//入栈后标记 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u]; i; i=e[i].next) &#123;<span class="comment">//遍历边 </span></span><br><span class="line"><span class="type">int</span> v = e[i].v;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v]) &#123;<span class="comment">//如果目标点没有被访问过</span></span><br><span class="line"><span class="built_in">tarjan</span>(v);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[v],low[u]);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(vis[v]) &#123;<span class="comment">//如果目标点被访问过而且还在栈中 </span></span><br><span class="line">low[u] = <span class="built_in">min</span>(dfn[v],low[u]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[u] == dfn[u]) &#123;<span class="comment">//如果该点是subtree(x)中的根 </span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,stack[index]);<span class="comment">//输出一组强联通分量 </span></span><br><span class="line">vis[stack[index]] = <span class="number">0</span>;</span><br><span class="line">index --;</span><br><span class="line">&#125; <span class="keyword">while</span>(u!=stack[index+<span class="number">1</span>]);<span class="comment">//从栈顶到x点的所有点都可以构成一个强连通分量 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">addnode</span>(x,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;<span class="comment">//如果没被访问过就从该点开始tarjan，以防有点未被访问 </span></span><br><span class="line"><span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1525 关押罪犯</title>
      <link href="/posts/57952.html"/>
      <url>/posts/57952.html</url>
      
        <content type="html"><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>S城现有两座监狱，一共关押着N名罪犯，编号分别为1−N。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为c的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为c的冲突事件。</p><p>每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到S城Z市长那里。公务繁忙的Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。<span id="more"></span></p><p>在详细考察了N名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。</p><p>那么，应如何分配罪犯，才能使Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？</p><h4 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><p>输入格式：<br>每行中两个数之间用一个空格隔开。第一行为两个正整数N,MN,M，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的MM行每行为三个正整数$a_j$,$b_j$,$c_j$，表示$a_j$号和$b_j$号罪犯之间存在仇恨，其怨气值为$c_j$。数据保证<script type="math/tex">1<a_j≤b_j≤N</script> ,<script type="math/tex">0 < c_j≤1,000,000,000</script> <script type="math/tex">1<a_j≤b_j≤N,0<c_j≤1,000,000,000</script>，且每对罪犯组合只出现一次。</p><p>输出格式：<br>共1 行，为Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出0。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>刚刚看完题面，明白了这道题一定有贪心的思想，我们需要优先处理矛盾值大的罪犯。再将目光转向输入格式，更是暗示了这道题就是一道图论题。</p><p>理一下条件：</p><blockquote><p>1、罪犯可以看作点<br>2、罪犯a与b的仇恨可以看做图中的边<br>3、仇恨值就是图中每条边的边权<br>4、所有点需要被分入两个不同的集合中。</p></blockquote><p>现在就可以知道，题目的模型是<strong>将点分别加入两个集合中，使最大边最小</strong>，自然就想到了<strong>二分+二分图判定</strong>，这个复杂度是肯定过得去的。</p><p>但是再深入分析一下，既然是将一个个点收集入两个集合中，看到集合就想到了并查集，于是就在并查集上继续深入思考。</p><h4 id="样例演绎"><a href="#样例演绎" class="headerlink" title="样例演绎"></a>样例演绎</h4><p>我们分析一下样例(图懒得画，就偷了LGOJ的图)：</p><p><img src="https://i.loli.net/2018/11/02/5bdc5412b3c8a.png" alt="298.png"></p><p>首先就可以想到：应当将边按边权从大到小排序，因为是要找最大值的最小值。</p><p>排序后序列: 28351,12884,6618,3512,2534,1805</p><p>在排序之后，从大到小处理，先将1,2归入两个不同的集合a,b中即$1\in a ,\ 2\in b$。</p><p>再将归入两个不同的集合中，即$3\in b,\ 4\in a$。</p><p>检验6618，发现其已经分开，再看3512，这条边的两端已经在同一个集合里了，而且它是第一个在一个集合里的边，由于排过序，所以直接输出该边权就是答案。</p><h4 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h4><p>由上面的分析已经很明了了。本题的大致思路就是将边排序，从大到小处理，分别将点加入两个不同的集合，若某集合有最大的边，就直接输出。</p><p>接下来就用代码来解释一下吧：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line"><span class="type">int</span> u,v,w;</span><br><span class="line">&#125;e[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> en[<span class="number">20005</span>],fa[<span class="number">20005</span>];<span class="comment">//en即enemy</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span><span class="comment">//日常快读</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> w = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">x = x*<span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line">x = x*w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Edge x,Edge y)</span><span class="comment">//按边权排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.w &gt; y.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//寻找祖先节点的函数（并查集）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x != fa[x]) x = fa[x] = fa[fa[x]];</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uni</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//合并函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">f</span>(x),b = <span class="built_in">f</span>(y);</span><br><span class="line">fa[b] = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//检查是否在一个集合中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">f</span>(x);</span><br><span class="line"><span class="type">int</span> b = <span class="built_in">f</span>(y);</span><br><span class="line"><span class="keyword">if</span>(a == b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">read</span>(n),<span class="built_in">read</span>(m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i] = i;<span class="comment">//初始化并查集</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line"><span class="built_in">read</span>(e[i].u),<span class="built_in">read</span>(e[i].v),<span class="built_in">read</span>(e[i].w);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(e+<span class="number">1</span>,e+<span class="number">1</span>+m,cmp);<span class="comment">//从大到小排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m+<span class="number">1</span>;i++)<span class="comment">//这里到m+1是因为如果没有冲突，就输出0</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(e[i].u,e[i].v))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,e[i].w);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!en[e[i].u]) en[e[i].u] = e[i].v;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">uni</span>(en[e[i].u],e[i].v);<span class="comment">//将自己前一个敌人与现在的敌人合并</span></span><br><span class="line"><span class="keyword">if</span>(!en[e[i].v]) en[e[i].v] = e[i].u;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">uni</span>(en[e[i].v],e[i].u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1268 树的重量</title>
      <link href="/posts/64822.html"/>
      <url>/posts/64822.html</url>
      
        <content type="html"><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>树可以用来表示物种之间的进化关系。一棵“进化树”是一个带边权的树，其叶节点表示一个物种，两个叶节点之间的距离表示两个物种的差异。现在，一个重要的问题是，根据物种之间的距离，重构相应的“进化树”。</p><p>令N={1..n}，用一个N上的矩阵M来定义树T。其中，矩阵M满足：对于任意的i，j，k，有M[i,j] + M[j,k] &gt;= M[i,k]。树T满足：</p><p>1．叶节点属于集合N；<span id="more"></span></p><p>2．边权均为非负整数；</p><p>3．dT(i,j)=M[i,j]，其中dT(i,j)表示树上i到j的最短路径长度。</p><p>如下图，矩阵M描述了一棵树。<br><img src="https://i.loli.net/2018/11/02/5bdb97d17403b.png" alt="树M"></p><p>树的重量是指树上所有边权之和。对于任意给出的合法矩阵M，它所能表示树的重量是惟一确定的，不可能找到两棵不同重量的树，它们都符合矩阵M。你的任务就是，根据给出的矩阵M，计算M所表示树的重量。下图是上面给出的矩阵M所能表示的一棵树，这棵树的总重量为15。<br><img src="https://i.loli.net/2018/11/02/5bdb9afc5e390.png" alt="83.png"></p><h4 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><p>输入格式：<br>输入数据包含若干组数据。每组数据的第一行是一个整数n(2&lt;n&lt;30)。其后n-1行，给出的是矩阵M的一个上三角(不包含对角线)，矩阵中所有元素是不超过100的非负整数。输入数据保证合法。</p><p>输入数据以n=0结尾。</p><p>输出格式：<br>对于每组输入，输出一行，一个整数，表示树的重量。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这是一道思维难度较大，但是代码难度较小的题目。</p><p>读完题面，第一反应就是有那么一点像最小生成树，于是就朝着这个方向进行思考。</p><p>但我们发现，输入给了两点之间的最短路，而不是边权，导致最小生成树的kruskal和prim算法就用不上了，思路渐渐开始偏向构造。</p><p>问题是：如何构造？</p><p>先考虑用邻接矩阵存图，因为数据少的可怜。<br>经过画图，于是我们就看到了下面的图：</p><p><img src="https://i.loli.net/2018/11/02/5bdba2bc9bb03.png" alt="构造1.png"></p><p>很显然，我们先初始化，将1,2两个点连起来，作为一条初始的边，这一条最短路一定是会加入总重量中的。</p><p><img src="https://i.loli.net/2018/11/02/5bdba352ac4d7.png" alt="构造2.png"></p><p>在这种加了一条边的情况下，我们要加上橙色的边权。<br>橙色的边权是很好求的: </p><script type="math/tex; mode=display">w_{3}=\frac{dis_{1,3}+dis_{2,3}-dis_{1,2}}{2}</script><p>再加一条边呢？</p><p><img src="https://i.loli.net/2018/11/02/5bdba5c59fba9.png" alt="树的重量.png"></p><p>我们发现，现在的情况明显要复杂一些。<br>虽然图中画出新边从橙边上分支出来，但是在加边之前，我们需要通过分析才能知道这条边的最小边权。</p><script type="math/tex; mode=display">若绿边是橙边的分支\ 则\ f_{1}=\frac{dis_{1,4}+dis_{3,4}-dis_{1,3}}{2}\\ 若绿边是黑边的分支\ 则\ f_{2}=\frac{dis_{1,4}+dis_{2,4}-dis_{1,2}}{2}\\ \therefore w_{4}=min(f_{1},f_{2})</script><p>以此类推，我们就可以得到当加入第i个点时，应该枚举i之前的点，再取最小值</p><script type="math/tex; mode=display">answer+=\sum_{i=3}^{n} min_{j=2}^{i-1}\frac{dis_{1,i}+dis_{j,i}-dis_{1,j}}{2}</script><p>既然思维方式已经出现了，我们就不难写出代码。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> dis[<span class="number">31</span>][<span class="number">31</span>],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> w = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">x = x*<span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line">x = x*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">read</span>(n);</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">read</span>(dis[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = dis[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;i;j++)</span><br><span class="line">&#123;</span><br><span class="line">temp = <span class="built_in">min</span>(temp,(dis[<span class="number">1</span>][i] + dis[j][i] - dis[<span class="number">1</span>][j])/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">ans+=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1330 封锁阳光大学</title>
      <link href="/posts/37487.html"/>
      <url>/posts/37487.html</url>
      
        <content type="html"><![CDATA[<p>URL: <a href="https://www.luogu.org/problemnew/show/P1330">https://www.luogu.org/problemnew/show/P1330</a></p><p>这道题的解题思路大体有两种：==染色搜索==和==并查集==。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>显然，搜索肯定是dfs和bfs，这两种搜索方式都是可行的。在此只讲述bfs的解题方法。</p><p>首先我们需要将题目抽象一下：</p><blockquote><p>1、整个图是一个无向连通图<br>2、一条边两个端点至少有一个点被染色<br>3、对于任意边的两个端点必须是两种不同的颜色<br>4、若任意边的两个端点的颜色相同，则认为其不合法。</p></blockquote><p>有了以上的抽象模型之后，我们就可以开始考虑代码。<span id="more"></span></p><h4 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h4><p>对于建图，<strong>我们认为无向图的一条边相当于两条相反的有向边</strong><br><img src="https://i.loli.net/2018/10/30/5bd80c16f051f.jpg" alt="无向图模型"></p><p>可以使用邻接表，但本人使用的是vector存图</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a[maxn];<span class="comment">//之前声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="comment">//main()函数中</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="built_in">read</span>(x);</span><br><span class="line"><span class="built_in">read</span>(y);</span><br><span class="line">a[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">a[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码核心部分-BFS"><a href="#代码核心部分-BFS" class="headerlink" title="代码核心部分(BFS)"></a>代码核心部分(BFS)</h4><p>需要声明一个数组ans[2],用来分别存两种不同颜色的节点的数量。</p><p>我们在搜索时可以判断是否一条边的两端点颜色一样。如果一样，就直接可以输出”Impossible”了。<br>反之，如果目标点没有被访问过，则将其推进队列中。并将其染成与当前点不同的颜色。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">int</span>(a[x].<span class="built_in">size</span>());i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c[a[x][i]] == c[x])<span class="comment">//两端点的颜色完全相同</span></span><br><span class="line">&#123;</span><br><span class="line">ans[<span class="number">0</span>] = ans[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!vis[a[x][i]])<span class="comment">// 没有被访问过</span></span><br><span class="line">&#123;</span><br><span class="line">q.<span class="built_in">push</span>(a[x][i]);</span><br><span class="line">c[a[x][i]] = (c[x] + <span class="number">1</span>)%<span class="number">2</span>;<span class="comment">//染色</span></span><br><span class="line">ans[c[a[x][i]]] ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于每一个点，我们都要对其进行bfs，再将答案数组中两个值取最小值加入最终答案中。</p><p>完整代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[maxn * <span class="number">10</span>],ans[<span class="number">2</span>],c[maxn * <span class="number">10</span>],ans_final;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[maxn];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> w = <span class="number">1</span>;</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">&#123;</span><br><span class="line">x = x*<span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line">x = x*w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">int</span>(a[x].<span class="built_in">size</span>());i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c[a[x][i]] == c[x])</span><br><span class="line">&#123;</span><br><span class="line">ans[<span class="number">0</span>] = ans[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!vis[a[x][i]])</span><br><span class="line">&#123;</span><br><span class="line">q.<span class="built_in">push</span>(a[x][i]);</span><br><span class="line">c[a[x][i]] = (c[x] + <span class="number">1</span>)%<span class="number">2</span>;</span><br><span class="line">ans[c[a[x][i]]] ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">read</span>(n);</span><br><span class="line"><span class="built_in">read</span>(m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="built_in">read</span>(x);</span><br><span class="line"><span class="built_in">read</span>(y);</span><br><span class="line">a[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">a[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(c,<span class="number">-1</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[i])</span><br><span class="line">&#123;</span><br><span class="line">ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">ans[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">c[i] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(i);</span><br><span class="line"><span class="built_in">bfs</span>();</span><br><span class="line"><span class="keyword">if</span>(ans[<span class="number">0</span>] == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans_final += <span class="built_in">min</span>(ans[<span class="number">0</span>],ans[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans_final);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多维动态规划</title>
      <link href="/posts/32861.html"/>
      <url>/posts/32861.html</url>
      
        <content type="html"><![CDATA[<h3 id="LGOJ-P1508-Likecloud-吃、吃、吃"><a href="#LGOJ-P1508-Likecloud-吃、吃、吃" class="headerlink" title="[LGOJ] P1508 Likecloud-吃、吃、吃"></a>[LGOJ] P1508 Likecloud-吃、吃、吃</h3><p>URL: <a href="https://www.luogu.org/problemnew/show/P1508">https://www.luogu.org/problemnew/show/P1508</a></p><p>   题面不给出了，这是一道典型的动规(Dynamic Programming)水题。  </p><p>   可以发现，虽然题面中是将人的位置作为起点，但是将人所在的位置作为输出最终的点比人一个个找更简单。</p><p>   我们由题目知道，对于人来说要找<strong>左前、前方、右前</strong>三个方向的数值，在这里，我们反过来仍然是一样的，所以可以很快的想出思路。</p><p>   动归方程： <script type="math/tex">F_{i,j} = \max (F_{i-1,j-1},F_{i-1,j},F_{i-1,j+1})+a_{i,j}</script>  </p><p>   在方程中，最大值函数(max)中，分别是左前，前，右前三个方向。<span id="more"></span></p><p>   下面给出自己的AC代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">501</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[maxn][maxn];<span class="comment">//这里存到此点的食物能量和最大值</span></span><br><span class="line"><span class="type">int</span> a[maxn][maxn];<span class="comment">//存此点食物能量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//手写最大值函数，在速度上比c++提供的函数max在速度上要快一些</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a &gt;= b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a &gt;= c) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a &lt; b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b &gt;= c) <span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="type">int</span> x = n,y = m/<span class="number">2</span> + <span class="number">1</span>;<span class="comment">//找人的位置</span></span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">f[i][j] = <span class="built_in">Max</span>(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j+<span class="number">1</span>],f[i<span class="number">-1</span>][j<span class="number">-1</span>])+a[i][j];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">Max</span>(f[x][y],f[x][y+<span class="number">1</span>],f[x][y<span class="number">-1</span>]));<span class="comment">//最后找此位置能吃的能量最大值。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LGOJ-P1387-最大正方形"><a href="#LGOJ-P1387-最大正方形" class="headerlink" title="[LGOJ] P1387 最大正方形"></a>[LGOJ] P1387 最大正方形</h3><p>URL:<a href="https://www.luogu.org/problemnew/show/P1387">https://www.luogu.org/problemnew/show/P1387</a></p><p>一看就是动规(Dynamic Programming)嘛，，，</p><p>实际上，本题有多种解法，首先是朴素(<del>暴力</del>)解法，这个算法的复杂度为$n^5$  ,所以根本不需要去考虑它。</p><p>第二种就是使用矩阵前缀和再枚举边长求解，时间复杂度为$O(n^3)$ ,如果将枚举改成二分枚举，可以将其时间复杂度优化到$O(n^2*logn)​$ , 但由于数据比较水，所以一定不会TLE，因此我刚写此题时首先就想到了这个方法。</p><p>但是首先想到的方法好像没有动规啊？接下来就是我们要写出的最优的解法，也就是多维动规，这种方法的时间复杂度是最小的，只有$O(n^2)$ 。但是这种方法相较于第二种方法来说需要一些推导。</p><p>首先我们思考一个问题：如果要形成一个正方形，需要什么条件呢？</p><p>毋庸置疑，在本题中，要形成一个正方形，0是肯定不能出现的，<strong>只要有一个0,那么0以及它周边的一切都是不能构成一个正方形的</strong>。</p><p>我们观察一下下面的表</p><div class="table-container"><table><thead><tr><th style="text-align:center">(1，1)</th><th style="text-align:center">(1，2)</th><th style="text-align:center">(1，3)</th></tr></thead><tbody><tr><td style="text-align:center"><strong>(2，1)</strong></td><td style="text-align:center"><strong>(2，2)</strong></td><td style="text-align:center"><strong>(2，3)</strong></td></tr><tr><td style="text-align:center"><strong>(3 ，1)</strong></td><td style="text-align:center"><strong>(3，2)</strong></td><td style="text-align:center"><strong>(3，3)</strong></td></tr></tbody></table></div><p>如果我们想让构成这样的一个$3\times3$的正方形，那么一定有必要条件：除了第一排和第一列，每个点和它左，左上，上三个点都必须是1。<br>于是我们开始考虑本题的状态转移方程，一定是与三个条件都满足，而我们动规数组中存的就是边数，所以要使其全部满足，一定要是取最小值</p><p>由此我们得到动规方程： <script type="math/tex">S_{i,j}=min(S_{i-1,j},S_{i-1,j-1},S_{i,j-1})+1</script> </p><p>我们的推导初步认为是没有问题的，那么就得出我们代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxn][maxn];<span class="comment">//存图</span></span><br><span class="line"><span class="type">int</span> s[maxn][maxn];<span class="comment">//存边</span></span><br><span class="line"><span class="type">int</span> n,m,ans = <span class="number">-233</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">s[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(s[i<span class="number">-1</span>][j],s[i][j<span class="number">-1</span>]),s[i<span class="number">-1</span>][j<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(s[i][j]&gt;ans) ans = s[i][j];</span><br><span class="line"><span class="comment">//printf(&quot;%d &quot;,s[i][j]);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ST算法</title>
      <link href="/posts/16342.html"/>
      <url>/posts/16342.html</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>ST表，刚接触的时候以为它是用来进行<del>省选基础</del>打表的，当实际上学习它的时候，发现<strong>它确实是用来打表的。</strong>  </p><p><strong>实际上，它就是一个二维数组。</strong>  </p><p>为什么它是用来打表的呢？ 举个<del>栗子</del> 例子，在我查看令人毛骨悚然的期末考试成绩表时，我一定会去看看谁是第一名，也就是最高分，用肉眼从上到下地进行查询，复杂度肯定是O(1)，因为排名最高的在表的顶端。但是电脑不一样，<del>它是个笨蛋，</del> 电脑是不知道成绩表的顶端是最大值(除非你将其sort排序一遍，但也是我知道排序之后顶端有最大值才告诉电脑，所以<del>电脑是个笨蛋</del>)。</p><p>ST表就与期末考试成绩表有点相似了，但仍然是不同的。<span id="more"></span></p><h4 id="相似点"><a href="#相似点" class="headerlink" title="相似点"></a>相似点</h4><p>ST表与普通的表一样，每次查询复杂度都是O(1)。</p><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>ST表只能维护区间最值，也就是鼎鼎大名的<strong>RMQ问题(Range Maximum/Minimun Query)</strong> <em>后面将会提到</em> ，但是它无法支持区间的求和问题，那是线段树干的事情了。</p><h4 id="原理：倍增"><a href="#原理：倍增" class="headerlink" title="原理：倍增"></a>原理：倍增</h4><p>  就是用二进制的方式，用更快的效率得到结果，，，</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>  终于进入了正题……<br>  <a href="https://www.luogu.org/problemnew/show/P3865">洛谷 P3865 【模板】ST表</a></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>  看到题的时候清晰明了，肯定的ST表，虽然是最简单的运算，但第一次写还是出锅了，，，<del>尴尬</del> </p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max(a,b) (a&gt;b?a:b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> tree[<span class="number">1000001</span>],n,m,N;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> p=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>((p&gt;<span class="string">&#x27;9&#x27;</span>||p&lt;<span class="string">&#x27;0&#x27;</span>)) p=<span class="built_in">getchar</span>();    </span><br><span class="line">    <span class="keyword">while</span>(!(p&gt;<span class="string">&#x27;9&#x27;</span>||p&lt;<span class="string">&#x27;0&#x27;</span>)) x=x*<span class="number">10</span>+p-<span class="string">&#x27;0&#x27;</span>,p=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(N=<span class="number">1</span>;N&lt;n;N&lt;&lt;=<span class="number">1</span>); N--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        tree[N+i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=N;i;i--)</span><br><span class="line">        tree[i]=<span class="built_in">Max</span>(tree[i&lt;&lt;<span class="number">1</span>],tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&amp;<span class="number">1</span>) ans=<span class="built_in">Max</span>(ans,tree[l]),l++;</span><br><span class="line">        <span class="keyword">if</span>(~r&amp;<span class="number">1</span>) ans=<span class="built_in">Max</span>(ans,tree[r]),r--;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;l) <span class="keyword">break</span>;</span><br><span class="line">        l&gt;&gt;=<span class="number">1</span>,r&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">         <span class="type">int</span> l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(l+N,r+N));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ST算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分约束</title>
      <link href="/posts/8856.html"/>
      <url>/posts/8856.html</url>
      
        <content type="html"><![CDATA[<h2 id="差分约束系统"><a href="#差分约束系统" class="headerlink" title="差分约束系统"></a>差分约束系统</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>   如果一个系统由n个变量与m个约束条件组成，形成形如 $a_i  - a_j \leq k (i,j \in [1,n],k为常数)$ 的不等式，则称其为差分约束系统</p><h3 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h3><p>   问题：<br>   给定n个变量与m个不等式，每个不等式为 x[i] - x[j] &lt;=a[k] (0 &lt;= i, j &lt; n, 0 &lt;= k &lt; m, a[k] 已知)，求x[i] - x[j] 的最大值。<span id="more"></span><br>   例如当 n = 4, m = 5, 如下的不等式组，求 $X_3 - X_0$ 的最大值。</p><script type="math/tex; mode=display">X_{1} - X_{0} \leq 1\\   X_{2} - X_{0} \leq 2\\   X_{3} - X_{0} \leq 4  \\   X_{2} - X_{1} \leq 3\\   X_{3} - X_{2} \leq 1</script><h3 id="差分约束与最短路模型"><a href="#差分约束与最短路模型" class="headerlink" title="差分约束与最短路模型"></a>差分约束与最短路模型</h3><p>   <strong>求解差分约束系统，都可以转化为图论中的单源最短路径(或最长路径)问题。</strong></p><p>   上面的不等式很容易联想到最短路重的三角不等式 d[v] &lt;= d[u] + w[u , v] 也即d[v] - d[u] &lt;= w[u , v]<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(dis[u]+<span class="built_in">w</span>(u,v) &lt;= dis[v])</span><br><span class="line">&#123;</span><br><span class="line">    dis[v] = dis[u] + <span class="built_in">w</span>(u,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>也就是与松弛操作相似,即使不等号方向相反也并不矛盾。</p><p>这两行代码主要实现的是使 dis[u] + w(u,v) &gt; dis[v] 。<br>具体操作：对于每一个不等式 x[i] - x[j] &lt;= a[k] , 对 j —&gt; i 建一条有向边，边权为a[k] , 求 x[n-1] - x[0] 的最大值就是0 —&gt; n-1 的最短路，两者刚刚吻合。所以这就是完美转换</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【模板】并查集</title>
      <link href="/posts/45567.html"/>
      <url>/posts/45567.html</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://www.luogu.org/problemnew/show/P3367">【模板】并查集</a></p><h3 id="什么是并查集"><a href="#什么是并查集" class="headerlink" title="什么是并查集?"></a>什么是并查集?</h3><p><strong>在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。</strong> 这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受；即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间（1～3秒）内计算出试题需要的结果，只能用并查集来描述。(<del>百度：你就这么复制走的吗？不打赏就走的吗？</del>)</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>大约有三种<br>在学习操作的时候，推荐链接:<a href="https://visualgo.net/zh/ufds">并查集图示</a></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>也就是让所有节点的爸爸（祖先）初始化为自己<br>这里有一个要点：由于树中每个点指向他的爸爸，而根节点没有爸爸，于是根节点的爸爸指针指向自己。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    fa[i]=i;</span><br></pre></td></tr></table></figure><br>这是进行其他操作的前提。<span id="more"></span></p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>   这里的查找即查找一个节点的祖先，要明确的是<strong>并查集是通过判断两个元素的根节点是否相同来确定这两个元素是否在同一集合</strong>，同时要记住<strong>只有根节点的爸爸指针指向自己</strong>。</p><p>   明确这两点之后，我们就可以很愉快的写出并查集中查找部分的代码了。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> r=x;<span class="comment">//将当前位置取出来</span></span><br><span class="line">    <span class="keyword">if</span>(r==fa[r]) <span class="keyword">return</span> r;<span class="comment">//如果爸爸指针指向自己，就到了根节点</span></span><br><span class="line">    <span class="keyword">return</span> fa[r]=<span class="built_in">f</span>(fa[r]);<span class="comment">//如果不是，就继续向根部寻找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><p>   接下来的合并就比较简单了，思路大致是这样的：  </p><ul><li>先判断两个元素是否在同一个集合内</li><li>如果不在，则将其中一个根节点指向另一个根节点(通俗点说，就是两个根节点中一个当另外一个的爸爸)</li><li>所以，我们认为<strong>根节点是一个集合的代表元素</strong> 。<br>那么代码：  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="built_in">find</span>(x),b=<span class="built_in">find</span>(y);<span class="comment">//记录两个元素的根节点</span></span><br><span class="line">    <span class="keyword">if</span>(a != b) fa[x]=y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>以上就是并查集的三个基本操作。</p><h3 id="实现与优化"><a href="#实现与优化" class="headerlink" title="实现与优化"></a>实现与优化</h3><p><del>终于到这里了</del> 由上所述，我们的到<strong>【模板】并查集</strong> 的完整代码:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">1000001</span>];<span class="comment">//存父亲节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------查找函数-------------</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">f</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p1,p2,p3;</span><br><span class="line">        cin&gt;&gt;p1&gt;&gt;p2&gt;&gt;p3;</span><br><span class="line">        <span class="keyword">if</span>(p1==<span class="number">1</span>) fa[<span class="built_in">f</span>(p2)]=fa[<span class="built_in">f</span>(p3)];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">f</span>(p2)==<span class="built_in">f</span>(p3))</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Y&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;N&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>好了，到现在为止，一切似乎都很完美了<br>但是，你可能遇到这种情况：<img src="https://i.loli.net/2018/08/05/5b66e4923352e.png" alt=""><br>就是TLE(<del>至少博主遇到了hh</del>)。<br>那么，我们该怎么办呢？<br>没错，就是努力地去优化代码。但是问题在于如何优化？<br>我给出的解决办法就是——<strong>秩优化</strong> </p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL总结(更新中)</title>
      <link href="/posts/27050.html"/>
      <url>/posts/27050.html</url>
      
        <content type="html"><![CDATA[<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>  vector就是不定长数组，<em>简单地说，就是一个可以存放任意类型的动态数组</em> 。</p><h3 id="特点及用法"><a href="#特点及用法" class="headerlink" title="特点及用法"></a>特点及用法</h3><p>  要使用vector，一定要有头文件以及命名空间std。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><br>vector的声明方式也是必不可少的<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector &lt;Elem&gt; c;<span class="comment">//创建一个空的vector</span></span><br><span class="line">vector &lt;Elem&gt; <span class="built_in">c1</span>(c2);<span class="comment">//复制一个vector</span></span><br><span class="line">vector &lt;Elem&gt; <span class="built_in">c</span>(n);<span class="comment">//创建一个含有n个数据的vector</span></span><br><span class="line">vector &lt;Elem&gt; <span class="built_in">c</span>(n,elem);<span class="comment">//创建一个含有n个elem元素的vector</span></span><br><span class="line">vector &lt;Elem&gt; <span class="built_in">c</span>(beg,end);<span class="comment">//创建一个 [beg,end)区间的vector</span></span><br><span class="line">c.~vector &lt;Elem&gt;();<span class="comment">//销毁所有数据，释放内存</span></span><br></pre></td></tr></table></figure><br>同时，vector也提供了对其进行操作的一部分函数。  <span id="more"></span><br>举例：有一个vector c;</p><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">表述</th></tr></thead><tbody><tr><td style="text-align:center">c.clear()</td><td style="text-align:center">移除容器中所有的元素</td></tr><tr><td style="text-align:center">c.erase(pos)</td><td style="text-align:center">删除pos位置的元素，并反回下一元素的位置</td></tr><tr><td style="text-align:center">c.erase(beg,end)</td><td style="text-align:center">删除区间[beg,end)中的数据，返回下一元素位置</td></tr><tr><td style="text-align:center">c.pop_back()</td><td style="text-align:center">删除最后一个元素</td></tr><tr><td style="text-align:center">c.push_back(element)</td><td style="text-align:center">在尾部加入一个元素</td></tr><tr><td style="text-align:center">c.empty()</td><td style="text-align:center">判断容器是否为空，若是，返回true,若不是,则返回false</td></tr><tr><td style="text-align:center">c1.swap(c2) or swap(c1,c2)</td><td style="text-align:center">将c1与c2元素互换</td></tr></tbody></table></div><h3 id="例题及其运用"><a href="#例题及其运用" class="headerlink" title="例题及其运用"></a>例题及其运用</h3><h4 id="例题：木块问题-UVa-101"><a href="#例题：木块问题-UVa-101" class="headerlink" title="例题：木块问题(UVa 101)"></a>例题：木块问题(UVa 101)</h4><p>从左到右有n个木块，编号为0~n-1，要求模拟以下四种操作  </p><ul><li><p>move a onto b: 把a与b上方的木块全部归位，然后将a叠在b的上面。</p></li><li><p>move a over b: 把a上方的木块全部归位，然后把a放在b所在木块堆的顶部。</p></li><li><p>pile a onto b: 把b上方木块全部归位，然后将a及上面的木块整体叠在b上面。</p></li><li><p>pile a over b: 把a及上面的木块整体叠在b所在木块堆顶部。</p><p>遇到quit时终止一组数据。a和b在同一堆的指令为非法指令，应当忽略。<br>所有操作结束后，输出每个位置的木块列表，按照从底部到顶部的顺序排列。</p></li></ul><p>【分析】<br>高度不确定时就适合用vector 保存；木块堆个数不超过n，所以用一个数组保存即可。<br>上代码<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; pile[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_block</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span>&amp; p,<span class="type">int</span>&amp; h)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(p=<span class="number">0</span>; p&lt;n; p++)</span><br><span class="line"><span class="keyword">for</span>(h=<span class="number">0</span>; h &lt; pile[p].<span class="built_in">size</span>(); h++)</span><br><span class="line"><span class="keyword">if</span>(pile[p][h] == a) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear_above</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=h+<span class="number">1</span>; i&lt;pile[p].<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line"><span class="type">int</span> b=pile[p][i];</span><br><span class="line">pile[b].<span class="built_in">push_back</span>(b);</span><br><span class="line">&#125;</span><br><span class="line">pile[p].<span class="built_in">resize</span>(h+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pile_onto</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> h,<span class="type">int</span> p2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=h; i &lt; pile[p].<span class="built_in">size</span>(); i++)</span><br><span class="line">pile[p2].<span class="built_in">push_back</span>(pile[p][i]);</span><br><span class="line">pile[p].<span class="built_in">resize</span>(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d:&quot;</span>,i);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;pile[i].<span class="built_in">size</span>(); j++) <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, pile[i][j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">string s1,s2;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) pile[i].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;s1&gt;&gt;a&gt;&gt;s2&gt;&gt;b) &#123;</span><br><span class="line"><span class="type">int</span> pa,pb,ha,hb;</span><br><span class="line"><span class="built_in">find_block</span>(a,pa,ha);</span><br><span class="line"><span class="built_in">find_block</span>(b,pb,hb);</span><br><span class="line"><span class="keyword">if</span>(pa == pb) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(s2 == <span class="string">&quot;onto&quot;</span>) <span class="built_in">clear_above</span>(pb,hb);</span><br><span class="line"><span class="keyword">if</span>(s1 == <span class="string">&quot;move&quot;</span>) <span class="built_in">clear_above</span>(pa,ha);</span><br><span class="line"><span class="built_in">pile_onto</span>( pa , ha , pb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">outt</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>木材加工题解</title>
      <link href="/posts/61961.html"/>
      <url>/posts/61961.html</url>
      
        <content type="html"><![CDATA[<p>传送门：<a href="https://www.luogu.org/problemnew/show/P2440">木材加工</a></p><p>用二分答案来解决这个问题。  </p><p>首先当然是找二分的两个端点值，左端点显然就是0了<br>那么右端点呢？<br>对于小部分的人大概会想当然的认为是最短的那根木头的长度（<del>就像我本人刚开始一样</del>）但是要注意题目中说木头可以丢掉但无法增加。<br>那么就很明显应当是所有木头加起来的长度除以题目要求分成的k段，得到的就是初始右端点的值（如果大于最短的那根木头，就可以把最短的丢掉）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">r=sum/k</span><br></pre></td></tr></table></figure><br>那么，接下来就是很关键的判断函数了。通过判断函数才能够选择左边还是右边的区间。 <span id="more"></span><br>判断函数如下：  </p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">num+=(a[i]/x); <span class="comment">//注意是每根木头除以长度的和，</span></span><br><span class="line">               <span class="comment">// 如果用总长度去求则可能有些木头过短需要丢掉，但是还是被算入其中 </span></span><br><span class="line"><span class="keyword">if</span>(num&gt;=k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再往后就是核心的二分函数（也可以在主函数中用递推，本人就使用递归）<br>有几点优化，有一点尤其要注意（不优化一定会被卡）：<br>如果左端点刚好等于所需要求的值，此时就会陷入死循环<br>例如：  </p><div class="table-container"><table><thead><tr><th style="text-align:center">次数</th><th style="text-align:center">l</th><th style="text-align:center">r</th><th style="text-align:left">mid</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:left">0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:left">0</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:left">0</td></tr></tbody></table></div><p>显然是有问题的。优化的方法是什么呢？<br>~~说出来可能有点emmm….. ~~那就是随机数大法<br>先上这部分代码<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>+<span class="built_in">rand</span>()%<span class="number">2</span>;</span><br></pre></td></tr></table></figure><br>这样就不会死循环，运气再不好也最多循环5~6次。当然有部分人是用+1的方式解决的，个人有个人的喜好。<br>其他的一些优化大家就自行领会了，献上完整代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100005</span>];<span class="comment">//存树 </span></span><br><span class="line"><span class="type">int</span> sum;<span class="comment">//记录所有树加起来的总长度 </span></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="comment">//判断函数 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">num+=(a[i]/x); <span class="comment">//注意是每根木头除以长度的和，</span></span><br><span class="line">               <span class="comment">// 如果用总长度去求则可能有些木头过短需要丢掉，但是还是被算入其中 </span></span><br><span class="line"><span class="keyword">if</span>(num&gt;=k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分函数 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(r&lt;=l) <span class="keyword">return</span> l;</span><br><span class="line"><span class="type">int</span> mid=(r+l)/<span class="number">2</span> + <span class="built_in">rand</span>()%<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(mid==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果小于一直接返回0 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">pd</span>(mid))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cut</span>(mid,r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cut</span>(l,mid<span class="number">-1</span>);<span class="comment">//最好是-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">sum+=a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r,l;</span><br><span class="line">r=sum/n;</span><br><span class="line">l=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans=<span class="built_in">cut</span>(l,r);</span><br><span class="line"><span class="keyword">if</span>(ans&lt;<span class="number">1</span>) cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
